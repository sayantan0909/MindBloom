rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a strict security model tailored for a mental
     * health application. It prioritizes user privacy by default. Data is segregated into
     * three main categories:
     *   1. Private User Data: Strictly owned by and accessible only to the user (e.g., profiles, screening results).
     *   2. Shared/Community Data: Readable by all signed-in users, but writable only by the original author (e.g., forum posts).
     *   3. Public Content: Globally readable resources managed by administrators (e.g., help articles, counselor lists).
     *
     * Data Structure: Private user data is nested under the `/users/{userId}` path to leverage
     * path-based security. Public and shared content resides in top-level collections.
     *
     * Key Security Decisions:
     * - Default Deny: All operations are denied unless explicitly permitted.
     * - User Privacy: Listing the top-level `/users` collection is forbidden to prevent user enumeration.
     * - Secure Queries: Global `list` operations are disabled on sensitive collections like `/counselorBookings` and `/chatMessages`
     *   to prevent data leakage, requiring clients to query for specific data they are authorized to see.
     * - Admin-Managed Content: Public resource collections (`mentalHealthResources`, `counselors`) are read-only for clients.
     *   Content must be managed through the Firebase Console or a trusted server environment.
     *
     * Denormalization for Authorization: To ensure fast and secure access checks, documents in shared
     * collections (e.g., `counselorBookings`, `forumPosts`) contain a denormalized `userId` field. This
     * allows rules to verify ownership directly from the document without performing costly and slow `get()` calls
     * on other documents.
     *
     * Structural Segregation: Private user data (like `screeningResults`) is placed in a subcollection
     * under the user's own document. This is a more secure and performant pattern than storing private
     * and public data in the same collection with a flag, especially for list operations.
     */

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for path-based security.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user is the owner of an existing document.
     * Used for update and delete operations on documents with a denormalized `userId`.
     */
    function isExistingOwner(doc) {
      return resource != null && isSignedIn() && request.auth.uid == doc.userId;
    }
    
    /**
     * Checks if the user is creating a document and correctly assigning
     * their own UID to its `userId` field.
     */
    function isCreatingOwnedDoc() {
      return isSignedIn() && request.resource.data.userId == request.auth.uid;
    }

    /**
     * Ensures a field is not changed during an update. Critical for preventing
     * users from re-assigning ownership of a document.
     */
    function isImmutable(field) {
      return request.resource.data[field] == resource.data[field];
    }


    // -------------------------------------------------------------------------
    // Collection Rules
    // -------------------------------------------------------------------------

    /**
     * @description Users can create and manage their own profile document.
     * @path /users/{userId}
     * @allow A signed-in user creates their own profile: `(create) /users/abc` with auth.uid=`abc`.
     * @deny A user tries to read another user's profile: `(get) /users/xyz` with auth.uid=`abc`.
     * @principle Restricts access to a user's own data tree and prevents user enumeration by disallowing list.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);

      /**
       * @description A user can manage their own private screening results.
       * @path /users/{userId}/screeningResults/{resultId}
       * @allow A user creates a new screening result for themselves: `(create) /users/abc/screeningResults/123` with auth.uid=`abc`.
       * @deny A user tries to list another user's results: `(list) /users/xyz/screeningResults` with auth.uid=`abc`.
       * @principle Enforces document ownership within a user's private data tree and validates relational integrity.
       */
      match /screeningResults/{resultId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isOwner(userId) && isImmutable('userId');
        allow delete: if isOwner(userId);
      }
    }

    /**
     * @description Publicly readable mental health content. Writes are disabled for clients.
     * @path /mentalHealthResources/{resourceId}
     * @allow Any user (even signed-out) reads a resource: `(get) /mentalHealthResources/123`.
     * @deny Any user tries to create a new resource: `(create) /mentalHealthResources/456`.
     * @principle Defines a public, read-only collection. Content should be managed by administrators.
     */
    match /mentalHealthResources/{resourceId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Publicly readable counselor profiles. Writes are disabled for clients.
     * @path /counselors/{counselorId}
     * @allow Any user (even signed-out) lists counselors: `(list) /counselors`.
     * @deny Any user tries to update a counselor profile: `(update) /counselors/dr-smith`.
     * @principle Defines a public, read-only collection. Content should be managed by administrators.
     */
    match /counselors/{counselorId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Users can manage their own counselor bookings. Access is restricted by a `userId` field on the document.
     * @path /counselorBookings/{bookingId}
     * @allow A user creates a booking, setting `userId` to their own UID: `(create) /counselorBookings/123` with `data.userId='abc'` and auth.uid=`abc`.
     * @deny A user tries to read another user's booking: `(get) /counselorBookings/456` (where data.userId=`xyz`) with auth.uid=`abc`.
     * @principle Enforces document ownership via a denormalized field and prevents data leakage by disallowing list.
     */
    match /counselorBookings/{bookingId} {
      allow get: if isExistingOwner(resource.data);
      allow list: if false;
      allow create: if isCreatingOwnedDoc();
      allow update: if isExistingOwner(resource.data) && isImmutable('userId');
      allow delete: if isExistingOwner(resource.data);
    }

    /**
     * @description Signed-in users can read all posts and can create/manage their own.
     * @path /forumPosts/{postId}
     * @allow A signed-in user reads any post: `(get) /forumPosts/xyz` with auth.uid=`abc`.
     * @deny An anonymous user tries to list posts: `(list) /forumPosts`.
     * @deny A user tries to delete another user's post: `(delete) /forumPosts/xyz` (where data.userId=`qwe`) with auth.uid=`abc`.
     * @principle Implements a "Public Read (for signed-in users) with Owner-Only Writes" model.
     */
    match /forumPosts/{postId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isCreatingOwnedDoc();
      allow update: if isExistingOwner(resource.data) && isImmutable('userId');
      allow delete: if isExistingOwner(resource.data);
    }

    /**
     * @description Users can manage their own private chat messages. Access is restricted by a `userId` field.
     * @path /chatMessages/{messageId}
     * @allow User `abc` creates a message for themselves: `(create) /chatMessages/123` with `data.userId='abc'` and auth.uid=`abc`.
     * @deny A user tries to list all chat messages in the system: `(list) /chatMessages`.
     * @principle Enforces document ownership via a denormalized field for highly private data, preventing data leakage.
     */
    match /chatMessages/{messageId} {
      allow get: if isExistingOwner(resource.data);
      allow list: if isSignedIn() && request.query.where.userId == request.auth.uid;
      allow create: if isCreatingOwnedDoc();
      allow update: if isExistingOwner(resource.data) && isImmutable('userId');
      allow delete: if isExistingOwner(resource.data);
    }
  }
}
